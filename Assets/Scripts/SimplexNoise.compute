#pragma kernel CSSimplex
#include "./FastNoiseLite.hlsl"


RWStructuredBuffer<float> noiseBuffer;

//static const float mFrequency = 0.01f;
static const float magnitude = 4000;

//static const int PrimeX = 501125321;
//static const int PrimeY = 1136930381;
//static const int PrimeZ = 1720413743;

float x;
float y;
float z;
int seed;
int seed1;
int size;

/*
static const float Gradients3D[256] =
{
    0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
    1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
    1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
    0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
    1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
    1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
    0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
    1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
    1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
    0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
    1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
    1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
    0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
    1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
    1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
    1, 1, 0, 0,  0,-1, 1, 0, -1, 1, 0, 0,  0,-1,-1, 0
};

int Hash(int seed, int xPrimed, int yPrimed, int zPrimed)
{
    int hash = seed ^ xPrimed ^ yPrimed ^ zPrimed;

    hash *= 0x27d4eb2d;
    return hash;
}

float GradCoord(int seed, int xPrimed, int yPrimed, int zPrimed, float xd, float yd, float zd)
{
    int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
    hash ^= hash >> 15;
    hash &= 63 << 2;

    float xg = Gradients3D[hash];
    float yg = Gradients3D[hash | 1];
    float zg = Gradients3D[hash | 2];

    return xd * xg + yd * yg + zd * zg;
}

int FastRound(float f)
{
    return f >= 0 ? (int) (f + 0.5f) : (int) (f - 0.5f);
}

float GetNoise(int seed, float x, float y, float z)
{
    int i = FastRound(x);
    int j = FastRound(y);
    int k = FastRound(z);

    float x0 = (float) (x - i);
    float y0 = (float) (y - j);
    float z0 = (float) (z - k);
    
    return z - k;
    
    int xNSign = (int) (-1.0f - x0) | 1;
    int yNSign = (int) (-1.0f - y0) | 1;
    int zNSign = (int) (-1.0f - z0) | 1;

    float ax0 = xNSign * -x0;
    float ay0 = yNSign * -y0;
    float az0 = zNSign * -z0;

    i *= PrimeX;
    j *= PrimeY;
    k *= PrimeZ;
    
    float value = 0;
    float a = (0.6f - x0 * x0) - (y0 * y0 + z0 * z0);

    for (int l = 0;; l++)
    {
        
        if (a > 0)
        {
            value += (a * a) * (a * a) * GradCoord(seed, i, j, k, x0, y0, z0);
        }

        if (ax0 >= ay0 && ax0 >= az0)
        {
            float b = a + ax0 + ax0;
            if (b > 1)
            {
                b -= 1;
                value += (b * b) * (b * b) * GradCoord(seed, i - xNSign * PrimeX, j, k, x0 + xNSign, y0, z0);
            }
        }

        else if (ay0 > ax0 && ay0 >= az0)
        {
            float b = a + ay0 + ay0;
            if (b > 1)
            {
                b -= 1;
                value += (b * b) * (b * b) * GradCoord(seed, i, j - yNSign * PrimeY, k, x0, y0 + yNSign, z0);
            }
        }
        else
        {
            float b = a + az0 + az0;
            if (b > 1)
            {
                b -= 1;
                value += (b * b) * (b * b) * GradCoord(seed, i, j, k - zNSign * PrimeZ, x0, y0, z0 + zNSign);
            }
        }

        if (l == 1)
            break;

        ax0 = 0.5f - ax0;
        ay0 = 0.5f - ay0;
        az0 = 0.5f - az0;

        x0 = xNSign * ax0;
        y0 = yNSign * ay0;
        z0 = zNSign * az0;

        a += (0.75f - ax0) - (ay0 + az0);

        i += (xNSign >> 1) & PrimeX;
        j += (yNSign >> 1) & PrimeY;
        k += (zNSign >> 1) & PrimeZ;

        xNSign = -xNSign;
        yNSign = -yNSign;
        zNSign = -zNSign;

        seed = ~seed;
    }

    return value * 32.69428253173828125f;
}
*/

int GetPos(int x, int y, int z)
{
    return x * size * size + y * size + z;
}


[numthreads(8,8,8)]
void CSSimplex (uint3 id : SV_DispatchThreadID)
{
    //x = mFrequency * id.x;
    //y = mFrequency * id.y;
    //z = mFrequency * id.z;

    //float r = (x + y + z) * 2 / 3;
    //x = r - x;
    //y = r - y;
    //z = r - z;
    fnl_state noise1 = fnlCreateState(seed, 0.0025f);
    fnl_state noise2 = fnlCreateState(seed, 0.005f);
    fnl_state noise3 = fnlCreateState(seed, 0.01f);
    fnl_state noise4 = fnlCreateState(seed, 0.02f);

    //fnl_state noise2 = fnlCreateState(seed1);
    //noise2.noise_type = FNL_NOISE_OPENSIMPLEX2;
    
    float n1 = fnlGetNoise3D(noise1, id.x * magnitude, id.y * magnitude, id.z * magnitude);
    float n2 = fnlGetNoise3D(noise2, id.x * magnitude/2, id.y * magnitude/2, id.z * magnitude/2);
    float n3 = fnlGetNoise3D(noise3, id.x * magnitude/4, id.y * magnitude/4, id.z * magnitude/4);
    float n4 = fnlGetNoise3D(noise4, id.x * magnitude/8, id.y * magnitude/8, id.z * magnitude/8);
    //float n2 = fnlGetNoise3D(noise2, id.x * magnitude, id.y * magnitude, id.z * magnitude);

    float combinedNoise = n1 + n2 + n3 + n4;
    
    combinedNoise *= 2.25f;
    combinedNoise += 1;
    combinedNoise /= 2;
    
    noiseBuffer[GetPos(id.x, id.y, id.z)] *= combinedNoise;
}
